#   â€¢ In this exercise, you will implement basic search algorithms and attempts to
#   confirm theoretical complexity findings with empirical measures
#   1. Implement linear search and binary search [0.5 pts] done
#   2. Measure the performance of each on sorted vectors of 1000, 2000, 4000,
#   8000, 16000, 32000 elements . In each case, you must do the following for
#   1000 times, and compute the average [0.5 pts]:
#       a. Pick a random element in the vector
#       b. Measure the time it takes to find the element using timeit, using 100
#       iterations (number=100)
import timeit
import random
import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import curve_fit

def linear_search(arr, x):
 
    for i in range(len(arr)):
 
        if arr[i] == x:
            return i
 
    return "not found"


def binary_search(arr, low, high, x):
 
    if high >= low:
 
        mid = (high + low) // 2
 
        if arr[mid] == x:
            return mid
        elif arr[mid] > x:
            return binary_search(arr, low, mid - 1, x)
        else:
            return binary_search(arr, mid + 1, high, x)
 
    else:
        # Element is not present in the array
        return "Not Found"
    
def calculate_time(search_type, vector_length, iterations):
    vector = random.sample(range(vector_length), vector_length)
    total_time = 0

    if (search_type == linear_search):
        for i in range(iterations):
            key = random.choice(vector)
            elapsed_time = timeit.timeit(lambda: linear_search(vector, key), number = iterations)
            elapsed_time += total_time

    elif (search_type == binary_search):
        for i in range(iterations):
            key = random.choice(vector)
            elapsed_time = timeit.timeit(lambda: binary_search(vector, 0, len(vector) - 1, key), number = iterations)
            total_time += elapsed_time

    return (total_time / iterations)


vector_lengths = [1000, 2000, 4000, 8000, 16000, 32000]
linear_search_times = []
binary_search_times = []

def linear_line(x, m, b):
    return (m*x + b)

def binary_line(x, a, b, c):
    return(a*pow(x, 2) + b*x + c)

for length in vector_lengths:
    linear_time = calculate_time(linear_search, length, 100)        
    linear_search_times.append(linear_time)

    binary_time = calculate_time(binary_search, length, 100)
    binary_search_times.append(binary_time)

plt.figure(figsize = (10, 8))

x = np.array(vector_lengths)
y_linear_search = np.array(linear_search_times)
y_binary_search = np.array(binary_search_times)

linear_parameters, _ = curve_fit(linear_line, x, y_linear_search)
binary_parameters, _ = curve_fit(binary_line, x, y_binary_search)

plt.scatter(x, y_linear_search, label = "Linear Search", color = 'green')
plt.plot(x, linear_line(x, *linear_parameters), label = "Linear Fit Line", color = 'green')

plt.scatter(x, y_binary_search, label = "Binary Search", color = 'purple')
plt.plot(x, binary_line(x, *binary_parameters), label = "Binary Fit Line", color = "purple")

plt.xlabel("Size of Vector")
plt.ylabel("Average Time (seconds)")
plt.legend()
plt.show()

# The first function used for our plot is a linear function, which is used to interpolate
# the line of best fit for linear search. This scatterplot showcases the time
# complexity for linear searching, which is O(n). The second function used is a quadratic function,
# which is used to plot the time complexity of a binary search.
# The parameters passed to the linear interpolating function are the vector of sizes (x values)
# and the parameters generated by the curve_fit function for a linear seach.
# The parameters given to the quadratic interpolating function are the vector of sizes (x values)
# and the parameters generated by the curve_fit function for the binary search.
# The results are mostly as expected. The binary search line shows a slightly quadratic
# but mostly logarithmic time complexity, which matches with the expected time complexity of O(log(n)).
# The linear search line shows a constant time complexity, which may be due to the smaller sample size
# of points on this scatter plot.
